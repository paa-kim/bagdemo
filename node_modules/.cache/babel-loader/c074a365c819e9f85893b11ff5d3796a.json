{"ast":null,"code":"var _jsxFileName = \"/Users/kim.lawrie/Development/bagdemo/bagdemo/src/index.js\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport * as cocoSsd from \"@tensorflow-models/coco-ssd\";\nimport \"@tensorflow/tfjs\";\nimport \"./index.css\";\nimport logo from './bag.png';\n\nclass App extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.videoRef = React.createRef();\n    this.canvasRef = React.createRef();\n\n    this.detectFrame = (video, model) => {\n      model.detect(video).then(predictions => {\n        this.renderPredictions(predictions);\n        requestAnimationFrame(() => {\n          this.detectFrame(video, model);\n        });\n      });\n    };\n\n    this.renderPredictions = predictions => {\n      const ctx = this.canvasRef.current.getContext(\"2d\");\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Font options.\n\n      const font = \"16px sans-serif\";\n      ctx.font = font;\n      ctx.textBaseline = \"top\";\n      predictions.forEach(prediction => {\n        const x = prediction.bbox[0];\n        const y = prediction.bbox[1];\n        const width = prediction.bbox[2];\n        const height = prediction.bbox[3]; // Draw the bounding box.\n\n        ctx.strokeStyle = \"#00FFFF\";\n        ctx.lineWidth = 4;\n        ctx.strokeRect(x, y, width, height); // Draw the label background.\n\n        ctx.fillStyle = \"#00FFFF\";\n        const textWidth = ctx.measureText(prediction.class).width;\n        const textHeight = parseInt(font, 10); // base 10\n\n        ctx.fillRect(x, y, textWidth + 4, textHeight + 4);\n      });\n      predictions.forEach(prediction => {\n        const x = prediction.bbox[0];\n        const y = prediction.bbox[1]; // Draw the text last to ensure it's on top.\n\n        ctx.fillStyle = \"#000000\";\n        ctx.fillText(prediction.class, x, y);\n      });\n    };\n  }\n\n  componentDidMount() {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      const webCamPromise = navigator.mediaDevices.getUserMedia({\n        audio: false,\n        video: {\n          facingMode: \"user\"\n        }\n      }).then(stream => {\n        window.stream = stream;\n        this.videoRef.current.srcObject = stream;\n        return new Promise((resolve, reject) => {\n          this.videoRef.current.onloadedmetadata = () => {\n            resolve();\n          };\n        });\n      });\n      const modelPromise = cocoSsd.load();\n      Promise.all([modelPromise, webCamPromise]).then(values => {\n        this.detectFrame(this.videoRef.current, values[0]);\n      }).catch(error => {\n        console.error(error);\n      });\n    }\n  }\n\n  render() {\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 85\n      },\n      __self: this\n    }, React.createElement(\"video\", {\n      className: \"size\",\n      autoPlay: true,\n      playsInline: true,\n      muted: true,\n      ref: this.videoRef,\n      width: \"600\",\n      height: \"500\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 86\n      },\n      __self: this\n    }), React.createElement(\"canvas\", {\n      className: \"size\",\n      ref: this.canvasRef,\n      width: \"600\",\n      height: \"500\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 95\n      },\n      __self: this\n    }));\n  }\n\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(React.createElement(App, {\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 107\n  },\n  __self: this\n}), rootElement);","map":{"version":3,"sources":["/Users/kim.lawrie/Development/bagdemo/bagdemo/src/index.js"],"names":["React","ReactDOM","cocoSsd","logo","App","Component","videoRef","createRef","canvasRef","detectFrame","video","model","detect","then","predictions","renderPredictions","requestAnimationFrame","ctx","current","getContext","clearRect","canvas","width","height","font","textBaseline","forEach","prediction","x","bbox","y","strokeStyle","lineWidth","strokeRect","fillStyle","textWidth","measureText","class","textHeight","parseInt","fillRect","fillText","componentDidMount","navigator","mediaDevices","getUserMedia","webCamPromise","audio","facingMode","stream","window","srcObject","Promise","resolve","reject","onloadedmetadata","modelPromise","load","all","values","catch","error","console","render","rootElement","document","getElementById"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport * as cocoSsd from \"@tensorflow-models/coco-ssd\";\nimport \"@tensorflow/tfjs\";\nimport \"./index.css\";\nimport logo from './bag.png';\n\nclass App extends React.Component {\n  videoRef = React.createRef();\n  canvasRef = React.createRef();\n\n  componentDidMount() {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      const webCamPromise = navigator.mediaDevices\n        .getUserMedia({\n          audio: false,\n          video: {\n            facingMode: \"user\"\n          }\n        })\n        .then(stream => {\n          window.stream = stream;\n          this.videoRef.current.srcObject = stream;\n          return new Promise((resolve, reject) => {\n            this.videoRef.current.onloadedmetadata = () => {\n              resolve();\n            };\n          });\n        });\n      const modelPromise = cocoSsd.load();\n      Promise.all([modelPromise, webCamPromise])\n        .then(values => {\n          this.detectFrame(this.videoRef.current, values[0]);\n        })\n        .catch(error => {\n          console.error(error);\n        });\n    }\n  }\n\n  detectFrame = (video, model) => {\n    model.detect(video).then(predictions => {\n      this.renderPredictions(predictions);\n      requestAnimationFrame(() => {\n        this.detectFrame(video, model);\n      });\n    });\n  };\n\n  renderPredictions = predictions => {\n    const ctx = this.canvasRef.current.getContext(\"2d\");\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    // Font options.\n    const font = \"16px sans-serif\";\n    ctx.font = font;\n    ctx.textBaseline = \"top\";\n    predictions.forEach(prediction => {\n      const x = prediction.bbox[0];\n      const y = prediction.bbox[1];\n      const width = prediction.bbox[2];\n      const height = prediction.bbox[3];\n      // Draw the bounding box.\n      ctx.strokeStyle = \"#00FFFF\";\n      ctx.lineWidth = 4;\n      ctx.strokeRect(x, y, width, height);\n      // Draw the label background.\n      ctx.fillStyle = \"#00FFFF\";\n      const textWidth = ctx.measureText(prediction.class).width;\n      const textHeight = parseInt(font, 10); // base 10\n      ctx.fillRect(x, y, textWidth + 4, textHeight + 4);\n    });\n\n    predictions.forEach(prediction => {\n      const x = prediction.bbox[0];\n      const y = prediction.bbox[1];\n      // Draw the text last to ensure it's on top.\n      ctx.fillStyle = \"#000000\";\n      ctx.fillText(prediction.class, x, y);\n    });\n  };\n\n  render() {\n    return (\n      <div>\n        <video\n          className=\"size\"\n          autoPlay\n          playsInline\n          muted\n          ref={this.videoRef}\n          width=\"600\"\n          height=\"500\"\n        />\n        <canvas\n          className=\"size\"\n          ref={this.canvasRef}\n          width=\"600\"\n          height=\"500\"\n        />\n      </div>\n    );\n  }\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n"]},"metadata":{},"sourceType":"module"}